import { AnalysisResult, MetricComparison, Recommendation, AutoFix } from '../types';

/**
 * Format analysis result as Markdown
 */
export function formatAsMarkdown(result: AnalysisResult): string {
  const sections: string[] = [];

  sections.push('# LHCI AI Analysis Report\n');
  sections.push(result.summary);
  sections.push('');

  // Regressions
  if (result.regressions.length > 0) {
    sections.push('## âš ï¸ Performance Regressions\n');
    sections.push(formatRegressionsTable(result.regressions));
    sections.push('');
  }

  // Improvements
  if (result.improvements.length > 0) {
    sections.push('## âœ… Improvements\n');
    sections.push(formatImprovementsList(result.improvements));
    sections.push('');
  }

  // Root causes
  if (result.rootCauses.length > 0) {
    sections.push('## ðŸ” Root Cause Analysis\n');
    for (const cause of result.rootCauses) {
      sections.push(`### ${cause.metric}\n`);
      sections.push(cause.cause);
      if (cause.relatedFiles && cause.relatedFiles.length > 0) {
        sections.push(`\n*Related files: ${cause.relatedFiles.join(', ')}*`);
      }
      sections.push('');
    }
  }

  // Recommendations
  if (result.recommendations.length > 0) {
    sections.push('## ðŸ’¡ Recommendations\n');
    sections.push(formatRecommendationsList(result.recommendations));
    sections.push('');
  }

  // Auto-fixes
  if (result.autoFixes && result.autoFixes.length > 0) {
    sections.push('## ðŸ”§ Suggested Fixes\n');
    sections.push(formatAutoFixesList(result.autoFixes));
    sections.push('');
  }

  sections.push('---');
  sections.push('*Generated by [lhci-ai-assistant](https://github.com/example/lhci-ai-assistant)*');

  return sections.join('\n');
}

/**
 * Format regressions as a Markdown table
 */
function formatRegressionsTable(regressions: MetricComparison[]): string {
  const lines: string[] = [];

  lines.push('| Metric | Before | After | Change | Severity |');
  lines.push('|--------|--------|-------|--------|----------|');

  for (const r of regressions) {
    const before = formatValue(r.metric, r.base);
    const after = formatValue(r.metric, r.current);
    const change = formatChange(r.metric, r.diff);
    const severity = formatSeverity(r.severity);

    lines.push(`| ${r.metric} | ${before} | ${after} | ${change} | ${severity} |`);
  }

  return lines.join('\n');
}

/**
 * Format improvements as a list
 */
function formatImprovementsList(improvements: MetricComparison[]): string {
  const lines: string[] = [];

  for (const i of improvements) {
    const before = formatValue(i.metric, i.base);
    const after = formatValue(i.metric, i.current);
    const change = formatChange(i.metric, i.diff);

    lines.push(`- **${i.metric}**: ${before} â†’ ${after} (${change})`);
  }

  return lines.join('\n');
}

/**
 * Format recommendations as a numbered list
 */
function formatRecommendationsList(recommendations: Recommendation[]): string {
  const lines: string[] = [];

  for (let i = 0; i < recommendations.length; i++) {
    const rec = recommendations[i];
    const priority = formatPriority(rec.priority);

    lines.push(`${i + 1}. ${priority} **${rec.title}**`);
    lines.push(`   ${rec.description}`);
    if (rec.impact) {
      lines.push(`   - *Impact: ${rec.impact}*`);
    }
    if (rec.effort) {
      lines.push(`   - *Effort: ${rec.effort}*`);
    }
    lines.push('');
  }

  return lines.join('\n');
}

/**
 * Format auto-fixes with collapsible sections
 */
function formatAutoFixesList(fixes: AutoFix[]): string {
  const lines: string[] = [];

  for (const fix of fixes) {
    const confidence = formatConfidence(fix.confidence);

    lines.push('<details>');
    lines.push(`<summary>${confidence} <strong>${fix.title}</strong> - ${fix.file}</summary>`);
    lines.push('');
    lines.push(fix.description);
    lines.push('');
    lines.push('```diff');
    lines.push(fix.diff);
    lines.push('```');
    lines.push('');
    lines.push('</details>');
    lines.push('');
  }

  return lines.join('\n');
}

/**
 * Format a metric value
 */
function formatValue(metric: string, value: number): string {
  if (metric.includes('Score')) {
    return `${(value * 100).toFixed(0)}%`;
  }
  if (metric === 'CLS') {
    return value.toFixed(3);
  }
  return `${value.toFixed(0)}ms`;
}

/**
 * Format a change value
 */
function formatChange(metric: string, diff: number): string {
  const sign = diff >= 0 ? '+' : '';

  if (metric.includes('Score')) {
    return `${sign}${(diff * 100).toFixed(1)}%`;
  }
  if (metric === 'CLS') {
    return `${sign}${diff.toFixed(3)}`;
  }
  return `${sign}${diff.toFixed(0)}ms`;
}

/**
 * Format severity with emoji
 */
function formatSeverity(severity: string): string {
  switch (severity) {
    case 'critical':
      return 'ðŸ”´ Critical';
    case 'high':
      return 'ðŸŸ  High';
    case 'medium':
      return 'ðŸŸ¡ Medium';
    case 'low':
      return 'ðŸŸ¢ Low';
    default:
      return severity;
  }
}

/**
 * Format priority with emoji
 */
function formatPriority(priority: string): string {
  switch (priority) {
    case 'high':
      return 'ðŸ”´';
    case 'medium':
      return 'ðŸŸ¡';
    case 'low':
      return 'ðŸŸ¢';
    default:
      return '';
  }
}

/**
 * Format confidence
 */
function formatConfidence(confidence: string): string {
  switch (confidence) {
    case 'high':
      return 'âœ…';
    case 'medium':
      return 'ðŸ”¶';
    case 'low':
      return 'â“';
    default:
      return '';
  }
}

/**
 * Format a simple Markdown summary for quick viewing
 */
export function formatQuickSummary(result: AnalysisResult): string {
  const lines: string[] = [];

  lines.push('**LHCI AI Summary**');
  lines.push('');

  if (result.regressions.length > 0) {
    const critical = result.regressions.filter((r) => r.severity === 'critical').length;
    const high = result.regressions.filter((r) => r.severity === 'high').length;

    lines.push(`âš ï¸ **${result.regressions.length}** regression(s) detected`);
    if (critical > 0) lines.push(`   - ${critical} critical`);
    if (high > 0) lines.push(`   - ${high} high severity`);
  } else {
    lines.push('âœ… No regressions detected');
  }

  if (result.improvements.length > 0) {
    lines.push(`âœ… **${result.improvements.length}** improvement(s)`);
  }

  if (result.recommendations.length > 0) {
    lines.push('');
    lines.push('**Top recommendations:**');
    for (const rec of result.recommendations.slice(0, 3)) {
      lines.push(`- ${rec.title}`);
    }
  }

  return lines.join('\n');
}
