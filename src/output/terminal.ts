import chalk from 'chalk';
import { AnalysisResult, MetricComparison, Recommendation, AutoFix } from '../types';

/**
 * Output analysis results to the terminal with colors
 */
export function outputToTerminal(result: AnalysisResult): void {
  console.log();
  console.log(chalk.bold.blue('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'));
  console.log(chalk.bold.blue('  LHCI AI Analysis Report'));
  console.log(chalk.bold.blue('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'));
  console.log();

  // Summary
  console.log(chalk.bold('Summary'));
  console.log(chalk.gray('â”€'.repeat(40)));
  console.log(result.summary);
  console.log();

  // Regressions
  if (result.regressions.length > 0) {
    console.log(chalk.bold.red('âš ï¸  Performance Regressions'));
    console.log(chalk.gray('â”€'.repeat(40)));
    outputRegressions(result.regressions);
    console.log();
  }

  // Improvements
  if (result.improvements.length > 0) {
    console.log(chalk.bold.green('âœ“ Improvements'));
    console.log(chalk.gray('â”€'.repeat(40)));
    outputImprovements(result.improvements);
    console.log();
  }

  // Root causes
  if (result.rootCauses.length > 0) {
    console.log(chalk.bold.yellow('ðŸ” Root Cause Analysis'));
    console.log(chalk.gray('â”€'.repeat(40)));
    for (const cause of result.rootCauses) {
      console.log(chalk.bold(`  ${cause.metric}:`));
      console.log(`    ${cause.cause}`);
      if (cause.relatedFiles && cause.relatedFiles.length > 0) {
        console.log(chalk.dim(`    Related: ${cause.relatedFiles.join(', ')}`));
      }
      console.log();
    }
  }

  // Recommendations
  if (result.recommendations.length > 0) {
    console.log(chalk.bold.cyan('ðŸ’¡ Recommendations'));
    console.log(chalk.gray('â”€'.repeat(40)));
    outputRecommendations(result.recommendations);
    console.log();
  }

  // Auto-fixes
  if (result.autoFixes && result.autoFixes.length > 0) {
    console.log(chalk.bold.magenta('ðŸ”§ Suggested Fixes'));
    console.log(chalk.gray('â”€'.repeat(40)));
    outputAutoFixes(result.autoFixes);
    console.log();
  }

  console.log(chalk.dim('â”€'.repeat(40)));
  console.log(chalk.dim('Generated by lhci-ai-assistant'));
  console.log();
}

/**
 * Output regressions with colored severity indicators
 */
function outputRegressions(regressions: MetricComparison[]): void {
  for (const r of regressions) {
    const severity = getSeverityColor(r.severity);
    const arrow = chalk.red('â†’');
    const before = formatValue(r.metric, r.base);
    const after = formatValue(r.metric, r.current);
    const change = formatChange(r.metric, r.diff);

    console.log(
      `  ${severity} ${chalk.bold(r.metric)}: ${before} ${arrow} ${after} (${chalk.red(change)})`
    );
  }
}

/**
 * Output improvements
 */
function outputImprovements(improvements: MetricComparison[]): void {
  for (const i of improvements) {
    const arrow = chalk.green('â†’');
    const before = formatValue(i.metric, i.base);
    const after = formatValue(i.metric, i.current);
    const change = formatChange(i.metric, i.diff);

    console.log(
      `  ${chalk.green('â—')} ${chalk.bold(i.metric)}: ${before} ${arrow} ${after} (${chalk.green(change)})`
    );
  }
}

/**
 * Output recommendations with priority colors
 */
function outputRecommendations(recommendations: Recommendation[]): void {
  for (const rec of recommendations) {
    const priority = getPriorityColor(rec.priority);
    console.log(`  ${priority} ${chalk.bold(rec.title)}`);
    console.log(chalk.dim(`     ${rec.description}`));
    if (rec.impact) {
      console.log(chalk.cyan(`     Impact: ${rec.impact}`));
    }
    console.log();
  }
}

/**
 * Output auto-fix suggestions
 */
function outputAutoFixes(fixes: AutoFix[]): void {
  for (const fix of fixes) {
    const confidence = getConfidenceColor(fix.confidence);
    console.log(`  ${confidence} ${chalk.bold(fix.title)}`);
    console.log(chalk.dim(`     File: ${fix.file}`));
    console.log(chalk.dim(`     ${fix.description}`));
    console.log();
    console.log(chalk.gray('     Diff:'));
    outputDiff(fix.diff);
    console.log();
  }
}

/**
 * Output a diff with syntax highlighting
 */
function outputDiff(diff: string): void {
  const lines = diff.split('\n');
  for (const line of lines) {
    if (line.startsWith('+')) {
      console.log(chalk.green(`     ${line}`));
    } else if (line.startsWith('-')) {
      console.log(chalk.red(`     ${line}`));
    } else {
      console.log(chalk.gray(`     ${line}`));
    }
  }
}

/**
 * Get colored severity indicator
 */
function getSeverityColor(severity: string): string {
  switch (severity) {
    case 'critical':
      return chalk.bgRed.white(' CRITICAL ');
    case 'high':
      return chalk.red('â—');
    case 'medium':
      return chalk.yellow('â—');
    case 'low':
      return chalk.blue('â—');
    default:
      return chalk.gray('â—');
  }
}

/**
 * Get colored priority indicator
 */
function getPriorityColor(priority: string): string {
  switch (priority) {
    case 'high':
      return chalk.red('â–²');
    case 'medium':
      return chalk.yellow('â– ');
    case 'low':
      return chalk.green('â–¼');
    default:
      return chalk.gray('â—');
  }
}

/**
 * Get colored confidence indicator
 */
function getConfidenceColor(confidence: string): string {
  switch (confidence) {
    case 'high':
      return chalk.green('âœ“');
    case 'medium':
      return chalk.yellow('â—‹');
    case 'low':
      return chalk.gray('?');
    default:
      return chalk.gray('â—');
  }
}

/**
 * Format a metric value for display
 */
function formatValue(metric: string, value: number): string {
  if (metric.includes('Score')) {
    return `${(value * 100).toFixed(0)}%`;
  }
  if (metric === 'CLS') {
    return value.toFixed(3);
  }
  return `${value.toFixed(0)}ms`;
}

/**
 * Format a change value for display
 */
function formatChange(metric: string, diff: number): string {
  const sign = diff >= 0 ? '+' : '';

  if (metric.includes('Score')) {
    return `${sign}${(diff * 100).toFixed(1)}%`;
  }
  if (metric === 'CLS') {
    return `${sign}${diff.toFixed(3)}`;
  }
  return `${sign}${diff.toFixed(0)}ms`;
}

/**
 * Output a simple progress message
 */
export function outputProgress(message: string): void {
  console.log(chalk.cyan(`â†’ ${message}`));
}

/**
 * Output a success message
 */
export function outputSuccess(message: string): void {
  console.log(chalk.green(`âœ“ ${message}`));
}

/**
 * Output an error message
 */
export function outputError(message: string): void {
  console.log(chalk.red(`âœ— ${message}`));
}

/**
 * Output a warning message
 */
export function outputWarning(message: string): void {
  console.log(chalk.yellow(`âš  ${message}`));
}
